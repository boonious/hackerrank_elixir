defmodule FPRecursionTest do
  use ExUnit.Case

  import ExUnit.CaptureIO
  import FP.Recursion

  doctest FP.Recursion

  describe "recursion" do
    @describetag :recursion
    
    #https://www.hackerrank.com/challenges/functional-programming-warmups-in-recursion---gcd/problem
    test "gcd - computing the greatest common divisor GCD using Euclidean Algorithm" do
      input = [1, 5]
      assert FP.Recursion.gcd(input) == 1

      input = [10, 100]
      assert FP.Recursion.gcd(input) == 10

      input = [1701, 3768]
      assert FP.Recursion.gcd(input) == 3
    
      input = [13, 13]
      assert FP.Recursion.gcd(input) == 13
    
      input = [144, 38]
      assert FP.Recursion.gcd(input) == 2
    end

    #https://www.hackerrank.com/challenges/functional-programming-warmups-in-recursion---fibonacci-numbers/problem
    test "fibonacci - Fibonacci numbers" do
      n = 3
      assert FP.Recursion.fibonacci(n) == 1

      n = 4
      assert FP.Recursion.fibonacci(n) == 2

      n = 5
      assert FP.Recursion.fibonacci(n) == 3
    end

    #https://www.hackerrank.com/challenges/pascals-triangle/problem
    test "pascal_tri - Pascal's triangle numbers" do
      n = 4
      assert FP.Recursion.pascal_tri_row(n-1) == [1,3,3,1]
      assert FP.Recursion.pascal_tri(n) === [[1], [1,1], [1,2,1], [1,3,3,1]]
    end

    #https://www.hackerrank.com/challenges/functions-and-fractals-sierpinski-triangles/problem
    test "draw_triangles - Functions and fractals: Sierpinski triangle" do
      fractal = FP.Recursion.draw_triangles(2)
      assert capture_io(fn ->
        fractal |> Enum.each(&IO.puts(&1 <> "\n"))
      end)
      ==
      "_______________________________1_______________________________\n
______________________________111______________________________\n
_____________________________11111_____________________________\n
____________________________1111111____________________________\n
___________________________111111111___________________________\n
__________________________11111111111__________________________\n
_________________________1111111111111_________________________\n
________________________111111111111111________________________\n
_______________________1_______________1_______________________\n
______________________111_____________111______________________\n
_____________________11111___________11111_____________________\n
____________________1111111_________1111111____________________\n
___________________111111111_______111111111___________________\n
__________________11111111111_____11111111111__________________\n
_________________1111111111111___1111111111111_________________\n
________________111111111111111_111111111111111________________\n
_______________1_______________________________1_______________\n
______________111_____________________________111______________\n
_____________11111___________________________11111_____________\n
____________1111111_________________________1111111____________\n
___________111111111_______________________111111111___________\n
__________11111111111_____________________11111111111__________\n
_________1111111111111___________________1111111111111_________\n
________111111111111111_________________111111111111111________\n
_______1_______________1_______________1_______________1_______\n
______111_____________111_____________111_____________111______\n
_____11111___________11111___________11111___________11111_____\n
____1111111_________1111111_________1111111_________1111111____\n
___111111111_______111111111_______111111111_______111111111___\n
__11111111111_____11111111111_____11111111111_____11111111111__\n
_1111111111111___1111111111111___1111111111111___1111111111111_\n
111111111111111_111111111111111_111111111111111_111111111111111\n
"
    end

    #https://www.hackerrank.com/challenges/string-o-permute/problem
    test "permute_string - String-o-permute" do
      assert FP.Recursion.permute_string("abcdpqrs") == "badcqpsr"
      assert FP.Recursion.permute_string("az") == "za"
    end

    #https://www.hackerrank.com/challenges/string-mingling/problem
    test "mingle_string - String mingling" do
      assert FP.Recursion.mingle_string(["abcde", "pqrst"]) == "apbqcrdset"
      assert FP.Recursion.mingle_string(["hacker", "ranker"]) == "hraacnkkeerr"
    end

    #https://www.hackerrank.com/challenges/fractal-trees/problem
    test "draw_trees - Functions and fractals, recursive trees" do
      assert FP.Recursion.draw_trees(5)
      == ["____________________________________________________________________________________________________",
         "__________________1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1___________________",
         "___________________1___1___1___1___1___1___1___1___1___1___1___1___1___1___1___1____________________",
         "___________________1___1___1___1___1___1___1___1___1___1___1___1___1___1___1___1____________________",
         "____________________1_1_____1_1_____1_1_____1_1_____1_1_____1_1_____1_1_____1_1_____________________",
         "_____________________1_______1_______1_______1_______1_______1_______1_______1______________________",
         "_____________________1_______1_______1_______1_______1_______1_______1_______1______________________",
         "_____________________1_______1_______1_______1_______1_______1_______1_______1______________________",
         "______________________1_____1_________1_____1_________1_____1_________1_____1_______________________",
         "_______________________1___1___________1___1___________1___1___________1___1________________________",
         "________________________1_1_____________1_1_____________1_1_____________1_1_________________________",
         "_________________________1_______________1_______________1_______________1__________________________",
         "_________________________1_______________1_______________1_______________1__________________________",
         "_________________________1_______________1_______________1_______________1__________________________",
         "_________________________1_______________1_______________1_______________1__________________________",
         "_________________________1_______________1_______________1_______________1__________________________",
         "__________________________1_____________1_________________1_____________1___________________________",
         "___________________________1___________1___________________1___________1____________________________",
         "____________________________1_________1_____________________1_________1_____________________________",
         "_____________________________1_______1_______________________1_______1______________________________",
         "______________________________1_____1_________________________1_____1_______________________________",
         "_______________________________1___1___________________________1___1________________________________",
         "________________________________1_1_____________________________1_1_________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "_________________________________1_______________________________1__________________________________",
         "__________________________________1_____________________________1___________________________________",
         "___________________________________1___________________________1____________________________________",
         "____________________________________1_________________________1_____________________________________",
         "_____________________________________1_______________________1______________________________________",
         "______________________________________1_____________________1_______________________________________",
         "_______________________________________1___________________1________________________________________",
         "________________________________________1_________________1_________________________________________",
         "_________________________________________1_______________1__________________________________________",
         "__________________________________________1_____________1___________________________________________",
         "___________________________________________1___________1____________________________________________",
         "____________________________________________1_________1_____________________________________________",
         "_____________________________________________1_______1______________________________________________",
         "______________________________________________1_____1_______________________________________________",
         "_______________________________________________1___1________________________________________________",
         "________________________________________________1_1_________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________",
         "_________________________________________________1__________________________________________________"]
    end

    #https://www.hackerrank.com/challenges/string-compression/problem
    test "compress_string - String compression" do
      assert FP.Recursion.compress_string("aaabaaaaccaaaaba") == "a3ba4c2a4ba"
    end

    #https://www.hackerrank.com/challenges/convex-hull-fp/problem
    test "graham_scan - algorithm for finding points on convex hull" do
      points = [{1,1},{2,5},{3,3},{5,3},{3,2},{2,2}]
      assert FP.Recursion.graham_scan(points) == [{1, 1}, {5, 3}, {2, 5}, {1, 1}]

      points = [{2,6},{4,6},{3,5},{0.1,4},{2.1,4},{4.1,4},{6.1,4},{1.3,3},{3.3,3},{5.3,3},{0,2},{2.1,2},{4.1,2},{6.1,2},{3,1},{2,0},{4,0}]
      assert FP.Recursion.graham_scan(points) == [{2,0},{4,0},{6.1,2},{6.1,4},{4,6},{2,6},{0.1,4},{0,2},{2,0}]

      points = [{113,201},{911,749},{839,217},{293,144},{290,848},{350,150},{143,995},{311,262},{923,748},{599,691},{128,790},{611,723},{881,577},{446,988},{209,589},{977,285},{512,813},{875,788},{566,674},{788,872},{320,738},{743,446},{227,271},{617,470},{761,859},{860,918},{866,868},{746,640},{167,39},{824,768},{593,184},{248,831},{197,232},{224,13},{677,131},{554,31},{35,572},{485,367},{422,828},{689,657},{314,954},{863,753},{806,315},{953,551},{992,351},{212,436},{917,26},{719,948},{707,606},{947,203},{119,798},{791,919},{260,394},{950,991},{59,164},{5,341},{92,191},{338,504},{383,695},{476,888},{602,133},{68,80},{818,277},{713,617},{827,971},{533,671},{455,300},{29,682},{605,71},{8,555},{32,449},{545,843},{215,526},{857,237},{926,634},{539,889},{335,656},{443,431},{269,402},{770,190},{680,978},{494,344},{242,763},{317,560},{803,73},{20,604},{785,154},{380,96},{536,669},{395,251},{236,977},{437,818},{389,412},{356,435},{23,500},{725,597},{587,481},{368,630},{776,791},{560,249}]
      assert FP.Recursion.graham_scan(points) == [{224, 13},{917, 26},{977, 285},{992, 351},{950, 991},{143, 995},{29, 682},{8, 555},{5, 341},{68, 80},{224, 13}]
    end

    test "convex_hull_perimeter - Convex hull" do
      points = [{1,1},{2,5},{3,3},{5,3},{3,2},{2,2}]
      assert FP.Recursion.convex_hull_perimeter(points) == 12.2

      points = [{3,2},{2,5},{4,5}]
      assert FP.Recursion.convex_hull_perimeter(points) == 8.3

      points = [{113,201},{911,749},{839,217},{293,144},{290,848},{350,150},{143,995},{311,262},{923,748},{599,691},{128,790},{611,723},{881,577},{446,988},{209,589},{977,285},{512,813},{875,788},{566,674},{788,872},{320,738},{743,446},{227,271},{617,470},{761,859},{860,918},{866,868},{746,640},{167,39},{824,768},{593,184},{248,831},{197,232},{224,13},{677,131},{554,31},{35,572},{485,367},{422,828},{689,657},{314,954},{863,753},{806,315},{953,551},{992,351},{212,436},{917,26},{719,948},{707,606},{947,203},{119,798},{791,919},{260,394},{950,991},{59,164},{5,341},{92,191},{338,504},{383,695},{476,888},{602,133},{68,80},{818,277},{713,617},{827,971},{533,671},{455,300},{29,682},{605,71},{8,555},{32,449},{545,843},{215,526},{857,237},{926,634},{539,889},{335,656},{443,431},{269,402},{770,190},{680,978},{494,344},{242,763},{317,560},{803,73},{20,604},{785,154},{380,96},{536,669},{395,251},{236,977},{437,818},{389,412},{356,435},{23,500},{725,597},{587,481},{368,630},{776,791},{560,249}]
      assert FP.Recursion.convex_hull_perimeter(points) == 3589.2
    end

    #https://www.hackerrank.com/challenges/prefix-compression/problem
    test "prefix_compress - Prefix compression" do
      assert FP.Recursion.prefix_compress(["abcdefpr","abcpqr"]) == [{3,"abc"},{5,"defpr"},{3,"pqr"}]
      assert FP.Recursion.prefix_compress(["kitkat","kit"]) == [{3,"kit"},{3,"kat"},{0,""}]
      assert FP.Recursion.prefix_compress(["puppy","puppy"]) == [{5,"puppy"},{0,""},{0,""}]
    end

    #https://www.hackerrank.com/challenges/string-reductions/problem
    test "string_reduce - String reduction" do
      assert FP.Recursion.string_reduce("accabb") == "acb"
      assert FP.Recursion.string_reduce("abc") == "abc"
      assert FP.Recursion.string_reduce("pprrqq") == "prq"
    end

    #https://www.hackerrank.com/challenges/functional-programming-the-sums-of-powers/problem
    test "sum_of_powers - The sums of power" do
      #assert FP.Recursion.sum_of_powers([10,2]) == 1
      assert FP.Recursion.sum_of_powers([100,2]) == 3
      #assert FP.Recursion.sum_of_powers([100,3]) == 1
    end

    # https://www.hackerrank.com/challenges/crosswords-101/problem
    test "parse - Crosswoeds 101, model/parse crosswords grid as list of position tuples series" do
      crossword_grid = ["+-++++++++",
      "+-++++++++",
      "+-++++++++",
      "+-----++++",
      "+-+++-++++",
      "+-+++-++++",
      "+++++-++++",
      "++------++",
      "+++++-++++",
      "+++++-++++"]

      assert parse(crossword_grid, :down)
      ==  [[{2, 1}, {2, 2}, {2, 3}, {2, 4}, {2, 5}, {2, 6}], [{6, 4}, {6, 5}, {6, 6}, {6, 7}, {6, 8}, {6, 9}, {6, 10}]]

      assert parse(crossword_grid, :across)
      == [[{2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}], [{3, 8}, {4, 8}, {5, 8}, {6, 8}, {7, 8}, {8, 8}]]

      assert parse(crossword_grid)
      == %{
        across: [
          [{2, 4}, {3, 4}, {4, 4}, {5, 4}, {6, 4}],
          [{3, 8}, {4, 8}, {5, 8}, {6, 8}, {7, 8}, {8, 8}]
        ],
        down: [
          [{2, 1}, {2, 2}, {2, 3}, {2, 4}, {2, 5}, {2, 6}],
          [{6, 4}, {6, 5}, {6, 6}, {6, 7}, {6, 8}, {6, 9}, {6, 10}]
        ]
      }

      crossword_grid = ["+-++++++++",
      "+-++++++++",
      "+-------++",
      "+-++++++++",
      "+-++++++++",
      "+------+++",
      "+-+++-++++",
      "+++++-++++",
      "+++++-++++",
      "++++++++++"]

      assert parse(crossword_grid, :down)
      == [[{2, 1}, {2, 2}, {2, 3}, {2, 4}, {2, 5}, {2, 6}, {2, 7}], [{6, 6}, {6, 7}, {6, 8}, {6, 9}]]

      assert parse(crossword_grid, :across)
      == [[{2, 3}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {8, 3}], [{2, 6}, {3, 6}, {4, 6}, {5, 6}, {6, 6}, {7, 6}]]

      assert parse(crossword_grid)
      == %{
        across: [
          [{2, 3}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {8, 3}],
          [{2, 6}, {3, 6}, {4, 6}, {5, 6}, {6, 6}, {7, 6}]
        ],
        down: [
          [{2, 1}, {2, 2}, {2, 3}, {2, 4}, {2, 5}, {2, 6}, {2, 7}],
          [{6, 6}, {6, 7}, {6, 8}, {6, 9}]
        ]
      }
    end

    test "fit - Crosswords 101, fit words into cell sequences to provide a candidate list for crossword solution" do
      crossword_grid = ["+-++++++++",
      "+-++++++++",
      "+-++++++++",
      "+-----++++",
      "+-+++-++++",
      "+-+++-++++",
      "+++++-++++",
      "++------++",
      "+++++-++++",
      "+++++-++++"]

      words = ["LONDON","DELHI","ICELAND","ANKARA"]
      sequences = parse(crossword_grid)

      assert fit(sequences.down, words)
      == [
        [
          [{"I", {6, 4}},{"C", {6, 5}},{"E", {6, 6}},{"L", {6, 7}},{"A", {6, 8}},{"N", {6, 9}},{"D", {6, 10}}]
        ],
        [
          [{"L", {2, 1}},{"O", {2, 2}},{"N", {2, 3}},{"D", {2, 4}},{"O", {2, 5}},{"N", {2, 6}}],
          [{"A", {2, 1}},{"N", {2, 2}},{"K", {2, 3}},{"A", {2, 4}},{"R", {2, 5}},{"A", {2, 6}}]
        ]
      ]

      assert fit(sequences.across, words)
      == [
        [
          [{"L", {3, 8}},{"O", {4, 8}},{"N", {5, 8}},{"D", {6, 8}},{"O", {7, 8}},{"N", {8, 8}}],
          [{"A", {3, 8}},{"N", {4, 8}},{"K", {5, 8}},{"A", {6, 8}},{"R", {7, 8}},{"A", {8, 8}}]
        ],
        [
          [{"D", {2, 4}},{"E", {3, 4}},{"L", {4, 4}},{"H", {5, 4}},{"I", {6, 4}}]
        ]
      ]

      crossword_grid = ["+-++++++++",
      "+-++++++++",
      "+-------++",
      "+-++++++++",
      "+-++++++++",
      "+------+++",
      "+-+++-++++",
      "+++++-++++",
      "+++++-++++",
      "++++++++++"]

      words = ["AGRA","NORWAY","ENGLAND","GWALIOR"]
      sequences = parse(crossword_grid)

      assert fit(sequences.down, words)
      == [
        [
          [{"A", {6, 6}}, {"G", {6, 7}}, {"R", {6, 8}}, {"A", {6, 9}}]
        ],
        [
          [{"E", {2, 1}}, {"N", {2, 2}}, {"G", {2, 3}}, {"L", {2, 4}}, {"A", {2, 5}}, {"N", {2, 6}}, {"D", {2, 7}}],
          [{"G", {2, 1}}, {"W", {2, 2}}, {"A", {2, 3}}, {"L", {2, 4}}, {"I", {2, 5}}, {"O", {2, 6}}, {"R", {2, 7}}]
        ]
      ]

      assert fit(sequences.across, words)
      == [
        [
          [{"N", {2, 6}}, {"O", {3, 6}}, {"R", {4, 6}}, {"W", {5, 6}}, {"A", {6, 6}}, {"Y", {7, 6}}]
        ],
        [
          [{"E", {2, 3}}, {"N", {3, 3}}, {"G", {4, 3}}, {"L", {5, 3}}, {"A", {6, 3}}, {"N", {7, 3}}, {"D", {8, 3}}],
          [{"G", {2, 3}}, {"W", {3, 3}}, {"A", {4, 3}}, {"L", {5, 3}}, {"I", {6, 3}}, {"O", {7, 3}}, {"R", {8, 3}}]
        ]
      ]
    end

    test "disambiguate - Crosswoeds 101, disambiguate a list of plausible fits, by cross checking words from the other orientation" do
      possible_fits = %{
        down: [
          [
            [{"I", {6, 4}},{"C", {6, 5}},{"E", {6, 6}},{"L", {6, 7}},{"A", {6, 8}},{"N", {6, 9}},{"D", {6, 10}}]
          ],
          [
            [{"L", {2, 1}},{"O", {2, 2}},{"N", {2, 3}},{"D", {2, 4}},{"O", {2, 5}},{"N", {2, 6}}],
            [{"A", {2, 1}},{"N", {2, 2}},{"K", {2, 3}},{"A", {2, 4}},{"R", {2, 5}},{"A", {2, 6}}]
          ]
        ],
        across: [
          [
            [{"L", {3, 8}},{"O", {4, 8}},{"N", {5, 8}},{"D", {6, 8}},{"O", {7, 8}},{"N", {8, 8}}],
            [{"A", {3, 8}},{"N", {4, 8}},{"K", {5, 8}},{"A", {6, 8}},{"R", {7, 8}},{"A", {8, 8}}]
          ],
          [
            [{"D", {2, 4}},{"E", {3, 4}},{"L", {4, 4}},{"H", {5, 4}},{"I", {6, 4}}]
          ]
        ]
      }

      assert disambiguate(possible_fits)
      == [
        [[{"L", {2, 1}},{"O", {2, 2}},{"N", {2, 3}},{"D", {2, 4}},{"O", {2, 5}},{"N", {2, 6}}]],
        [[{"I", {6, 4}},{"C", {6, 5}},{"E", {6, 6}},{"L", {6, 7}},{"A", {6, 8}},{"N", {6, 9}},{"D", {6, 10}}]],
        [[{"D", {2, 4}},{"E", {3, 4}},{"L", {4, 4}},{"H", {5, 4}},{"I", {6, 4}}]],
        [[{"A", {3, 8}},{"N", {4, 8}},{"K", {5, 8}},{"A", {6, 8}},{"R", {7, 8}},{"A", {8, 8}}]]
      ]

      possible_fits = %{
        down: [
          [
            [{"A", {6, 6}}, {"G", {6, 7}}, {"R", {6, 8}}, {"A", {6, 9}}]
          ],
          [
            [{"E", {2, 1}}, {"N", {2, 2}}, {"G", {2, 3}}, {"L", {2, 4}}, {"A", {2, 5}}, {"N", {2, 6}}, {"D", {2, 7}}],
            [{"G", {2, 1}}, {"W", {2, 2}}, {"A", {2, 3}}, {"L", {2, 4}}, {"I", {2, 5}}, {"O", {2, 6}}, {"R", {2, 7}}]
          ]
        ],
        across: [
          [
            [{"N", {2, 6}}, {"O", {3, 6}}, {"R", {4, 6}}, {"W", {5, 6}}, {"A", {6, 6}}, {"Y", {7, 6}}]
          ],
          [
            [{"E", {2, 3}}, {"N", {3, 3}}, {"G", {4, 3}}, {"L", {5, 3}}, {"A", {6, 3}}, {"N", {7, 3}}, {"D", {8, 3}}],
            [{"G", {2, 3}}, {"W", {3, 3}}, {"A", {4, 3}}, {"L", {5, 3}}, {"I", {6, 3}}, {"O", {7, 3}}, {"R", {8, 3}}]
          ]
        ]
      }

      assert disambiguate(possible_fits)
      == [
        [[{"E", {2, 1}}, {"N", {2, 2}}, {"G", {2, 3}}, {"L", {2, 4}}, {"A", {2, 5}}, {"N", {2, 6}}, {"D", {2, 7}}]],
        [[{"A", {6, 6}}, {"G", {6, 7}}, {"R", {6, 8}}, {"A", {6, 9}}]],
        [[{"G", {2, 3}}, {"W", {3, 3}}, {"A", {4, 3}}, {"L", {5, 3}}, {"I", {6, 3}}, {"O", {7, 3}}, {"R", {8, 3}}]],
        [[{"N", {2, 6}}, {"O", {3, 6}}, {"R", {4, 6}}, {"W", {5, 6}}, {"A", {6, 6}}, {"Y", {7, 6}}]]
      ]
    end

    test "render - Crosswoeds 101, render solution" do
      solution = [
        [[{"E", {2, 1}}, {"N", {2, 2}}, {"G", {2, 3}}, {"L", {2, 4}}, {"A", {2, 5}}, {"N", {2, 6}}, {"D", {2, 7}}]],
        [[{"A", {6, 6}}, {"G", {6, 7}}, {"R", {6, 8}}, {"A", {6, 9}}]],
        [[{"G", {2, 3}}, {"W", {3, 3}}, {"A", {4, 3}}, {"L", {5, 3}}, {"I", {6, 3}}, {"O", {7, 3}}, {"R", {8, 3}}]],
        [[{"N", {2, 6}}, {"O", {3, 6}}, {"R", {4, 6}}, {"W", {5, 6}}, {"A", {6, 6}}, {"Y", {7, 6}}]]
      ]

      assert render(solution)
      == ["+E++++++++",
          "+N++++++++",
          "+GWALIOR++",
          "+L++++++++",
          "+A++++++++",
          "+NORWAY+++",
          "+D+++G++++",
          "+++++R++++",
          "+++++A++++",
          "++++++++++"]

      solution = [
        [[{"L", {2, 1}},{"O", {2, 2}},{"N", {2, 3}},{"D", {2, 4}},{"O", {2, 5}},{"N", {2, 6}}]],
        [[{"I", {6, 4}},{"C", {6, 5}},{"E", {6, 6}},{"L", {6, 7}},{"A", {6, 8}},{"N", {6, 9}},{"D", {6, 10}}]],
        [[{"D", {2, 4}},{"E", {3, 4}},{"L", {4, 4}},{"H", {5, 4}},{"I", {6, 4}}]],
        [[{"A", {3, 8}},{"N", {4, 8}},{"K", {5, 8}},{"A", {6, 8}},{"R", {7, 8}},{"A", {8, 8}}]]
      ]

      assert render(solution)
      == ["+L++++++++",
          "+O++++++++",
          "+N++++++++",
          "+DELHI++++",
          "+O+++C++++",
          "+N+++E++++",
          "+++++L++++",
          "++ANKARA++",
          "+++++N++++",
          "+++++D++++"]
    end

  end

end
